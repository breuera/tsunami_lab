<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tsunami Reis: tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tsunami Reis
   </div>
   <div id="projectbrief">Tsunami Simulation Justus Dre√üler</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="top"></a> </p>
<h1><a class="anchor" id="autotoc_md487"></a>
Tutorial</h1>
<p><b>Contents</b><br  />
 <a href="#getting-catch2">Getting Catch2</a><br  />
 <a href="#where-to-put-it">Where to put it?</a><br  />
 <a href="#writing-tests">Writing tests</a><br  />
 <a href="#test-cases-and-sections">Test cases and sections</a><br  />
 <a href="#bdd-style">BDD-Style</a><br  />
 <a href="#scaling-up">Scaling up</a><br  />
 <a href="#type-parametrised-test-cases">Type parametrised test cases</a><br  />
 <a href="#next-steps">Next steps</a><br  />
</p>
<h2><a class="anchor" id="autotoc_md488"></a>
Getting Catch2</h2>
<p>The simplest way to get Catch2 is to download the latest <a href="https://raw.githubusercontent.com/catchorg/Catch2/v2.x/single_include/catch2/catch.hpp">single header version</a>. The single header is generated by merging a set of individual headers but it is still just normal source code in a header file.</p>
<p>Alternative ways of getting Catch2 include using your system package manager, or installing it using <a href="cmake-integration.md#installing-catch2-from-git-repository">its CMake package</a>.</p>
<p>The full source for Catch2, including test projects, documentation, and other things, is hosted on GitHub. <a href="http://catch-lib.net">http://catch-lib.net</a> will redirect you there.</p>
<h2><a class="anchor" id="autotoc_md489"></a>
Where to put it?</h2>
<p>Catch2 is header only. All you need to do is drop the file somewhere reachable from your project - either in some central location you can set your header search path to find, or directly into your project tree itself! This is a particularly good option for other Open-Source projects that want to use Catch for their test suite. See <a href="https://levelofindirection.com/blog/unit-testing-in-cpp-and-objective-c-just-got-ridiculously-easier-still.html">this blog entry for more on that</a>.</p>
<p>The rest of this tutorial will assume that the Catch2 single-include header (or the include folder) is available unqualified - but you may need to prefix it with a folder name if necessary.</p>
<p><em>If you have installed Catch2 from system package manager, or CMake package, you need to include the header as <code>#include &lt;<a class="el" href="single__include_2catch2_2catch_8hpp_source.html">catch2/catch.hpp</a>&gt;</code></em></p>
<h2><a class="anchor" id="autotoc_md490"></a>
Writing tests</h2>
<p>Let's start with a really simple example (<a href="../examples/010-TestCase.cpp">code</a>). Say you have written a function to calculate factorials and now you want to test it (let's leave aside TDD for now).</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">unsigned int Factorial( unsigned int number ) {</div>
<div class="line">    return number &lt;= 1 ? number : Factorial(number-1)*number;</div>
<div class="line">}</div>
</div><!-- fragment --><p>To keep things simple we'll put everything in a single file (<a href="#scaling-up">see later for more on how to structure your test files</a>).</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#define CATCH_CONFIG_MAIN  // This tells Catch to provide a main() - only do this in one cpp file</div>
<div class="line">#include &quot;catch.hpp&quot;</div>
<div class="line"> </div>
<div class="line">unsigned int Factorial( unsigned int number ) {</div>
<div class="line">    return number &lt;= 1 ? number : Factorial(number-1)*number;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST_CASE( &quot;Factorials are computed&quot;, &quot;[factorial]&quot; ) {</div>
<div class="line">    REQUIRE( Factorial(1) == 1 );</div>
<div class="line">    REQUIRE( Factorial(2) == 2 );</div>
<div class="line">    REQUIRE( Factorial(3) == 6 );</div>
<div class="line">    REQUIRE( Factorial(10) == 3628800 );</div>
<div class="line">}</div>
</div><!-- fragment --><p>This will compile to a complete executable which responds to <a href="command-line.md#top">command line arguments</a>. If you just run it with no arguments it will execute all test cases (in this case there is just one), report any failures, report a summary of how many tests passed and failed and return the number of failed tests (useful for if you just want a yes/ no answer to: "did it work").</p>
<p>If you run this as written it will pass. Everything is good. Right? Well, there is still a bug here. In fact the first version of this tutorial I posted here genuinely had the bug in! So it's not completely contrived (thanks to Daryle Walker (<code>@CTMacUser</code>) for pointing this out).</p>
<p>What is the bug? Well what is the factorial of zero? <a href="http://mathforum.org/library/drmath/view/57128.html">The factorial of zero is one</a> - which is just one of those things you have to know (and remember!).</p>
<p>Let's add that to the test case:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">TEST_CASE( &quot;Factorials are computed&quot;, &quot;[factorial]&quot; ) {</div>
<div class="line">    REQUIRE( Factorial(0) == 1 );</div>
<div class="line">    REQUIRE( Factorial(1) == 1 );</div>
<div class="line">    REQUIRE( Factorial(2) == 2 );</div>
<div class="line">    REQUIRE( Factorial(3) == 6 );</div>
<div class="line">    REQUIRE( Factorial(10) == 3628800 );</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now we get a failure - something like:</p>
<div class="fragment"><div class="line">Example.cpp:9: FAILED:</div>
<div class="line">  REQUIRE( Factorial(0) == 1 )</div>
<div class="line">with expansion:</div>
<div class="line">  0 == 1</div>
</div><!-- fragment --><p>Note that we get the actual return value of Factorial(0) printed for us (0) - even though we used a natural expression with the == operator. That lets us immediately see what the problem is.</p>
<p>Let's change the factorial function to:</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">unsigned int Factorial( unsigned int number ) {</div>
<div class="line">  return number &gt; 1 ? Factorial(number-1)*number : 1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now all the tests pass.</p>
<p>Of course there are still more issues to deal with. For example we'll hit problems when the return value starts to exceed the range of an unsigned int. With factorials that can happen quite quickly. You might want to add tests for such cases and decide how to handle them. We'll stop short of doing that here.</p>
<h3><a class="anchor" id="autotoc_md491"></a>
What did we do here?</h3>
<p>Although this was a simple test it's been enough to demonstrate a few things about how Catch is used. Let's take a moment to consider those before we move on.</p>
<ol type="1">
<li>All we did was <code>#define</code> one identifier and <code>#include</code> one header and we got everything - even an implementation of <code>main()</code> that will <a href="command-line.md#top">respond to command line arguments</a>. You can only use that <code>#define</code> in one implementation file, for (hopefully) obvious reasons. Once you have more than one file with unit tests in you'll just <code>#include "catch.hpp"</code> and go. Usually it's a good idea to have a dedicated implementation file that just has <code>#define CATCH_CONFIG_MAIN</code> and <code>#include "catch.hpp"</code>. You can also provide your own implementation of main and drive Catch yourself (see <a href="own-main.md#top">Supplying-your-own-main()</a>).</li>
<li>We introduce test cases with the <code>TEST_CASE</code> macro. This macro takes one or two arguments - a free form test name and, optionally, one or more tags (for more see <a href="#test-cases-and-sections">Test cases and Sections</a>). The test name must be unique. You can run sets of tests by specifying a wildcarded test name or a tag expression. See the <a href="command-line.md#top">command line docs</a> for more information on running tests.</li>
<li>The name and tags arguments are just strings. We haven't had to declare a function or method - or explicitly register the test case anywhere. Behind the scenes a function with a generated name is defined for you, and automatically registered using static registry classes. By abstracting the function name away we can name our tests without the constraints of identifier names.</li>
<li>We write our individual test assertions using the <code>REQUIRE</code> macro. Rather than a separate macro for each type of condition we express the condition naturally using C/C++ syntax. Behind the scenes a simple set of expression templates captures the left-hand-side and right-hand-side of the expression so we can display the values in our test report. As we'll see later there <em>are</em> other assertion macros - but because of this technique the number of them is drastically reduced.</li>
</ol>
<p><a class="anchor" id="test-cases-and-sections"></a> </p>
<h2><a class="anchor" id="autotoc_md492"></a>
Test cases and sections</h2>
<p>Most test frameworks have a class-based fixture mechanism. That is, test cases map to methods on a class and common setup and teardown can be performed in <code>setup()</code> and <code>teardown()</code> methods (or constructor/ destructor in languages, like C++, that support deterministic destruction).</p>
<p>While Catch fully supports this way of working there are a few problems with the approach. In particular the way your code must be split up, and the blunt granularity of it, may cause problems. You can only have one setup/ teardown pair across a set of methods, but sometimes you want slightly different setup in each method, or you may even want several levels of setup (a concept which we will clarify later on in this tutorial). It was <a href="http://jamesnewkirk.typepad.com/posts/2007/09/why-you-should-.html">problems like these</a> that led James Newkirk, who led the team that built NUnit, to start again from scratch and <a href="http://jamesnewkirk.typepad.com/posts/2007/09/announcing-xuni.html">build xUnit</a>).</p>
<p>Catch takes a different approach (to both NUnit and xUnit) that is a more natural fit for C++ and the C family of languages. This is best explained through an example (<a href="../examples/100-Fix-Section.cpp">code</a>):</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">TEST_CASE( &quot;vectors can be sized and resized&quot;, &quot;[vector]&quot; ) {</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;int&gt; v( 5 );</div>
<div class="line"> </div>
<div class="line">    REQUIRE( v.size() == 5 );</div>
<div class="line">    REQUIRE( v.capacity() &gt;= 5 );</div>
<div class="line"> </div>
<div class="line">    SECTION( &quot;resizing bigger changes size and capacity&quot; ) {</div>
<div class="line">        v.resize( 10 );</div>
<div class="line"> </div>
<div class="line">        REQUIRE( v.size() == 10 );</div>
<div class="line">        REQUIRE( v.capacity() &gt;= 10 );</div>
<div class="line">    }</div>
<div class="line">    SECTION( &quot;resizing smaller changes size but not capacity&quot; ) {</div>
<div class="line">        v.resize( 0 );</div>
<div class="line"> </div>
<div class="line">        REQUIRE( v.size() == 0 );</div>
<div class="line">        REQUIRE( v.capacity() &gt;= 5 );</div>
<div class="line">    }</div>
<div class="line">    SECTION( &quot;reserving bigger changes capacity but not size&quot; ) {</div>
<div class="line">        v.reserve( 10 );</div>
<div class="line"> </div>
<div class="line">        REQUIRE( v.size() == 5 );</div>
<div class="line">        REQUIRE( v.capacity() &gt;= 10 );</div>
<div class="line">    }</div>
<div class="line">    SECTION( &quot;reserving smaller does not change size or capacity&quot; ) {</div>
<div class="line">        v.reserve( 0 );</div>
<div class="line"> </div>
<div class="line">        REQUIRE( v.size() == 5 );</div>
<div class="line">        REQUIRE( v.capacity() &gt;= 5 );</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>For each <code>SECTION</code> the <code>TEST_CASE</code> is executed from the start - so as we enter each section we know that size is 5 and capacity is at least 5. We enforced those requirements with the <code>REQUIRE</code>s at the top level so we can be confident in them. This works because the <code>SECTION</code> macro contains an if statement that calls back into Catch to see if the section should be executed. One leaf section is executed on each run through a <code>TEST_CASE</code>. The other sections are skipped. Next time through the next section is executed, and so on until no new sections are encountered.</p>
<p>So far so good - this is already an improvement on the setup/teardown approach because now we see our setup code inline and use the stack.</p>
<p>The power of sections really shows, however, when we need to execute a sequence of checked operations. Continuing the vector example, we might want to verify that attempting to reserve a capacity smaller than the current capacity of the vector changes nothing. We can do that, naturally, like so:</p>
<div class="fragment"><div class="line">{c++}</div>
<div class="line">   SECTION( &quot;reserving bigger changes capacity but not size&quot; ) {</div>
<div class="line">       v.reserve( 10 );</div>
<div class="line"> </div>
<div class="line">       REQUIRE( v.size() == 5 );</div>
<div class="line">       REQUIRE( v.capacity() &gt;= 10 );</div>
<div class="line"> </div>
<div class="line">       SECTION( &quot;reserving smaller again does not change capacity&quot; ) {</div>
<div class="line">           v.reserve( 7 );</div>
<div class="line"> </div>
<div class="line">           REQUIRE( v.capacity() &gt;= 10 );</div>
<div class="line">       }</div>
<div class="line">   }</div>
</div><!-- fragment --><p>Sections can be nested to an arbitrary depth (limited only by your stack size). Each leaf section (i.e. a section that contains no nested sections) will be executed exactly once, on a separate path of execution from any other leaf section (so no leaf section can interfere with another). A failure in a parent section will prevent nested sections from running - but then that's the idea.</p>
<h2><a class="anchor" id="autotoc_md493"></a>
BDD-Style</h2>
<p>If you name your test cases and sections appropriately you can achieve a BDD-style specification structure. This became such a useful way of working that first class support has been added to Catch. Scenarios can be specified using <code>SCENARIO</code>, <code>GIVEN</code>, <code>WHEN</code> and <code>THEN</code> macros, which map on to <code>TEST_CASE</code>s and <code>SECTION</code>s, respectively. For more details see <a href="test-cases-and-sections.md#top">Test cases and sections</a>.</p>
<p>The vector example can be adjusted to use these macros like so (<a href="../examples/120-Bdd-ScenarioGivenWhenThen.cpp">example code</a>):</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">SCENARIO( &quot;vectors can be sized and resized&quot;, &quot;[vector]&quot; ) {</div>
<div class="line"> </div>
<div class="line">    GIVEN( &quot;A vector with some items&quot; ) {</div>
<div class="line">        std::vector&lt;int&gt; v( 5 );</div>
<div class="line"> </div>
<div class="line">        REQUIRE( v.size() == 5 );</div>
<div class="line">        REQUIRE( v.capacity() &gt;= 5 );</div>
<div class="line"> </div>
<div class="line">        WHEN( &quot;the size is increased&quot; ) {</div>
<div class="line">            v.resize( 10 );</div>
<div class="line"> </div>
<div class="line">            THEN( &quot;the size and capacity change&quot; ) {</div>
<div class="line">                REQUIRE( v.size() == 10 );</div>
<div class="line">                REQUIRE( v.capacity() &gt;= 10 );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        WHEN( &quot;the size is reduced&quot; ) {</div>
<div class="line">            v.resize( 0 );</div>
<div class="line"> </div>
<div class="line">            THEN( &quot;the size changes but not capacity&quot; ) {</div>
<div class="line">                REQUIRE( v.size() == 0 );</div>
<div class="line">                REQUIRE( v.capacity() &gt;= 5 );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        WHEN( &quot;more capacity is reserved&quot; ) {</div>
<div class="line">            v.reserve( 10 );</div>
<div class="line"> </div>
<div class="line">            THEN( &quot;the capacity changes but not the size&quot; ) {</div>
<div class="line">                REQUIRE( v.size() == 5 );</div>
<div class="line">                REQUIRE( v.capacity() &gt;= 10 );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        WHEN( &quot;less capacity is reserved&quot; ) {</div>
<div class="line">            v.reserve( 0 );</div>
<div class="line"> </div>
<div class="line">            THEN( &quot;neither size nor capacity are changed&quot; ) {</div>
<div class="line">                REQUIRE( v.size() == 5 );</div>
<div class="line">                REQUIRE( v.capacity() &gt;= 5 );</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Conveniently, these tests will be reported as follows when run:</p>
<div class="fragment"><div class="line">Scenario: vectors can be sized and resized</div>
<div class="line">     Given: A vector with some items</div>
<div class="line">      When: more capacity is reserved</div>
<div class="line">      Then: the capacity changes but not the size</div>
</div><!-- fragment --><p><a class="anchor" id="scaling-up"></a> </p>
<h2><a class="anchor" id="autotoc_md494"></a>
Scaling up</h2>
<p>To keep the tutorial simple we put all our code in a single file. This is fine to get started - and makes jumping into Catch even quicker and easier. As you write more real-world tests, though, this is not really the best approach.</p>
<p>The requirement is that the following block of code (<a href="own-main.md#top">or equivalent</a>):</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">#define CATCH_CONFIG_MAIN</div>
<div class="line">#include &quot;catch.hpp&quot;</div>
</div><!-- fragment --><p>appears in <em>exactly one</em> source file. Use as many additional cpp files (or whatever you call your implementation files) as you need for your tests, partitioned however makes most sense for your way of working. Each additional file need only <code>#include "catch.hpp"</code> - do not repeat the <code>#define</code>!</p>
<p>In fact it is usually a good idea to put the block with the <code>#define</code> <a href="slow-compiles.md#top">in its own source file</a> (code example <a href="../examples/020-TestCase-1.cpp">main</a>, <a href="../examples/020-TestCase-2.cpp">tests</a>).</p>
<p>Do not write your tests in header files!</p>
<h2><a class="anchor" id="autotoc_md495"></a>
Type parametrised test cases</h2>
<p>Test cases in Catch2 can be also parametrised by type, via the <code>TEMPLATE_TEST_CASE</code> and <code>TEMPLATE_PRODUCT_TEST_CASE</code> macros, which behave in the same way the <code>TEST_CASE</code> macro, but are run for every type or type combination.</p>
<p>For more details, see our documentation on <a href="test-cases-and-sections.md#type-parametrised-test-cases">test cases and sections</a>.</p>
<h2><a class="anchor" id="autotoc_md496"></a>
Next steps</h2>
<p>This has been a brief introduction to get you up and running with Catch, and to point out some of the key differences between Catch and other frameworks you may already be familiar with. This will get you going quite far already and you are now in a position to dive in and write some tests.</p>
<p>Of course there is more to learn - most of which you should be able to page-fault in as you go. Please see the ever-growing <a href="Readme.md#top">Reference section</a> for what's available.</p>
<hr  />
<p><a href="Readme.md#top">Home</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
